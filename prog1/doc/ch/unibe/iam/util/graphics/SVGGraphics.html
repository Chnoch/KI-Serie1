<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_03) on Mon Nov 01 14:33:57 CET 2004 -->
<TITLE>
SVGGraphics
</TITLE>

<META NAME="keywords" CONTENT="ch.unibe.iam.util.graphics.SVGGraphics class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="SVGGraphics";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SVGGraphics.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../ch/unibe/iam/util/graphics/RegularPolygon.html" title="class in ch.unibe.iam.util.graphics"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SVGGraphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ch.unibe.iam.util.graphics</FONT>
<BR>
Class SVGGraphics</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by">java.awt.Graphics
      <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by">java.awt.Graphics2D
          <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by"><B>ch.unibe.iam.util.graphics.SVGGraphics</B>
</PRE>
<HR>
<DL>
<DT>public class <B>SVGGraphics</B><DT>extends java.awt.Graphics2D</DL>

<P>
SVG generator for Java.
 <p>
 Using this class makes it easy(er) to generate SVG files from Java. The intention is to
 use SVG as a kind of "screen dump", using possibly the same user methods as for the 
 generation of the screen content. This is the reason why the object is defined as 
 an extension of <code>Graphics2D</code>: various methods which can use any
 <code>Graphics2D</code> instances can be used in conjunction with this class. The 
 approach is similar to the printing facilities in Java.
 Here is a typical usage of the class:
 <pre>
      SVGGraphics svg = SVGGraphics.create(yourCanvas);
      if( svg == null ) return;
      yourCanvas.yourDrawMethod(svg);
      svg.close();
 </pre>
 Note the usage of the <code>close</code> method, which is necessary to properly close
 the SVG file.
 <p>
 Most of the graphics calls in <code>Graphics2D</code> translate into SVG easily.
 There are some differences, difficulties, or not-yet-implemented features, though, check the
 comments on the individual methods themselves.
 The generated SVG file includes a number of groups: one for each
 different transformation and/or stroke settings. Gradient colours of Java are 
 separated into a distinct set of definitions.
 <p>
 Coordinates in the generated SVG file are simply passed on from Java,
 and the transformation matrices in the groups take care of the proper positioning. The only
 exception are the coordinates in the linear gradients in the definitions, where the 
 coordinates are transformed before being stored in the file. 
 <p>
 As mentioned before most of the Java calls can be translated into SVG easily. The only
 major exception is the handling of images. In Java, images are pixels (by the time the 
 methods in <code>Graphics</code> are called) whereas SVG refers to URL-s. I did not see any
 obvious ways to store pixel information in SVG and, even if it was possible, it would be
 a waste of bandwidth. The solution chosen in <code>SVGGraphics</code> is to accept
 only those <code>Image</code> objects, whose property with a key <code>"url"</code> has been set.
 This url is then used as a reference in the SVG file. 
 The only problem with using <code>"url"</code> key for an image that it is not immediately
 obvious how one would set a property on an image. For reasons which I do not completely understand,
 although there is a public <code>getProperty</code> method for an <code>Image</code> object,
 there is no public <code>setProperty</code> method. The only way I found was to use a special
 image consumer filter to generate a new <code>Image</code> instance with the property set. To
 make life easier for the users of <code>SVGGraphics</code>, a separate class, called
 <CODE><code>SVGImageFilter</code></CODE>, is available. See the description of that class for further details
 on how to use it. Note that the same restriction applies for the texture paint: the buffered image 
 which is used in a texture paint has to include the <code>"url"</code> property. If it is there,
 a separate pattern specification (in SVG terms) is generated into the output.
 <p>
 The user might also want to look at the class 
 <CODE>STest</CODE> which 
 I used for testing <code>SVGGraphics</code>.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.1</DD>
<DT><B>Author:</B></DT>
  <DD>Ivan Herman</DD>
<DT><B>See Also:</B><DD><CODE>SVGImageFilter</CODE></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#addRenderingHints(java.util.Map)">addRenderingHints</A></B>(java.util.Map&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the values of an arbitrary number of preferences for the
 rendering algorithms.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clearRect(int, int, int, int)">clearRect</A></B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the specified rectangle by filling it with the background
 color of the current drawing surface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clip(java.awt.Shape)">clip</A></B>(java.awt.Shape&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intersects the current <code>Clip</code> with the interior of the
 specified <code>Shape</code> and sets the <code>Clip</code> to the
 resulting intersection. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clipRect(int, int, int, int)">clipRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intersects the current clip with the specified rectangle.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#close(boolean)">close</A></B>(boolean&nbsp;closeFile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#copyArea(int, int, int, int, int, int)">copyArea</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;dx,
         int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies an area of the component by a distance specified by 
 <code>dx</code> and <code>dy</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Graphics</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#create()">create</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>Graphics</code> object that is 
 a copy of this <code>Graphics</code> object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html" title="class in ch.unibe.iam.util.graphics">SVGGraphics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#create(java.io.PrintStream, java.awt.Component)">create</A></B>(java.io.PrintStream&nbsp;o,
       java.awt.Component&nbsp;origin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new <code>SVGGraphics</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is inherited from the superclass. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#draw(java.awt.Shape)">draw</A></B>(java.awt.Shape&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strokes the outline of a <code>Shape</code> using the settings of the 
 current <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawArc(int, int, int, int, int, int)">drawArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of a circular or elliptical arc 
 covering the specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawGlyphVector(java.awt.font.GlyphVector, float, float)">drawGlyphVector</A></B>(java.awt.font.GlyphVector&nbsp;g,
                float&nbsp;x,
                float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the text of the specified 
 GlyphVector using
 the <code>Graphics2D</code> context's rendering attributes.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)">drawImage</A></B>(java.awt.image.BufferedImage&nbsp;img,
          java.awt.image.BufferedImageOp&nbsp;op,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders a <code>BufferedImage</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          java.awt.geom.AffineTransform&nbsp;xform,
          java.awt.image.ImageObserver&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders an image, applying a transform from image space into user space
 before drawing.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          java.awt.Color&nbsp;bgcolor,
          java.awt.image.ImageObserver&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified image as is currently available.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          java.awt.image.ImageObserver&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified image as is currently available.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          java.awt.Color&nbsp;bgcolor,
          java.awt.image.ImageObserver&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified image as has already been scaled
 to fit inside the specified rectangle.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          java.awt.image.ImageObserver&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified image as has already been scaled
 to fit inside the specified rectangle.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          java.awt.Color&nbsp;bgcolor,
          java.awt.image.ImageObserver&nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified area of the specified image as is
 currently available, scaling it on the fly to fit inside the
 specified area of the destination drawable surface. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A></B>(java.awt.Image&nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          java.awt.image.ImageObserver&nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws as much of the specified area of the specified image as is
 currently available, scaling it on the fly to fit inside the
 specified area of the destination drawable surface. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawLine(int, int, int, int)">drawLine</A></B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a line.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawOval(int, int, int, int)">drawOval</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of an oval.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawPolygon(int[], int[], int)">drawPolygon</A></B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a closed polygon defined by 
 arrays of <i>x</i> and <i>y</i> coordinates. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawPolyline(int[], int[], int)">drawPolyline</A></B>(int[]&nbsp;xPoints,
             int[]&nbsp;yPoints,
             int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a sequence of connected lines defined by 
 arrays of <i>x</i> and <i>y</i> coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawRect(int, int, int, int)">drawRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)">drawRenderableImage</A></B>(java.awt.image.renderable.RenderableImage&nbsp;img,
                    java.awt.geom.AffineTransform&nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a renderable image
 <strong>Handling of renderable images is not implemented.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)">drawRenderedImage</A></B>(java.awt.image.RenderedImage&nbsp;img,
                  java.awt.geom.AffineTransform&nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rendered image
 <strong>Handling of rendered images is not implemented.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an outlined round-cornered rectangle using this graphics 
 context's current color. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawString(java.text.AttributedCharacterIterator, float, float)">drawString</A></B>(java.text.AttributedCharacterIterator&nbsp;iterator,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the text of the specified iterator, using the
 <code>Graphics2D</code> context's current <code>Paint</code>. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A></B>(java.text.AttributedCharacterIterator&nbsp;iterator,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the text of the specified iterator, using the
 <code>Graphics2D</code> context's current <code>Paint</code>. 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawString(java.lang.String, float, float)">drawString</A></B>(java.lang.String&nbsp;s,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the text specified by the specified <code>String</code>, 
 using the current <code>Font</code> and <code>Paint</code> attributes 
 in the <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawString(java.lang.String, int, int)">drawString</A></B>(java.lang.String&nbsp;s,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the text of the specified <code>String</code>, using the 
 current <code>Font</code> and <code>Paint</code> attributes in the 
 <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fill(java.awt.Shape)">fill</A></B>(java.awt.Shape&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the interior of a <code>Shape</code> using the settings of the   
 <code>Graphics2D</code> context. .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fillArc(int, int, int, int, int, int)">fillArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a circular or elliptical arc covering the specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fillOval(int, int, int, int)">fillOval</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills an oval bounded by the specified rectangle with the
 current color.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fillPolygon(int[], int[], int)">fillPolygon</A></B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a closed polygon defined by 
 arrays of <i>x</i> and <i>y</i> coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fillRect(int, int, int, int)">fillRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rounded corner rectangle with the current color.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Color</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getBackground()">getBackground</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the background colour used for clearing a region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Shape</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getClip()">getClip</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current clipping area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Rectangle</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getClipBounds()">getClipBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the bounding rectangle of the current clipping area.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Color</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getColor()">getColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets this graphics context's current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Composite</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getComposite()">getComposite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <code>Composite</code> in the
 <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.GraphicsConfiguration</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getDeviceConfiguration()">getDeviceConfiguration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the device configuration associated with this 
 <code>Graphics2D</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Font</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getFont()">getFont</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current font.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.FontMetrics</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getFontMetrics(java.awt.Font)">getFontMetrics</A></B>(java.awt.Font&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the font metrics for the specified font.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.font.FontRenderContext</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getFontRenderContext()">getFontRenderContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the rendering context of the <code>Font</code> within this 
 <code>Graphics2D</code> context.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Paint</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getPaint()">getPaint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <code>Paint</code> of the 
 <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getRenderingHint(java.awt.RenderingHints.Key)">getRenderingHint</A></B>(java.awt.RenderingHints.Key&nbsp;hintKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of a single preference for the rendering algorithms.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.RenderingHints</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getRenderingHints()">getRenderingHints</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the preferences for the rendering algorithms.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Stroke</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getStroke()">getStroke</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current <code>Stroke</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#getTransform()">getTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <em>copy</em> of the current <code>Transform</code> in the 
 <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#hit(java.awt.Rectangle, java.awt.Shape, boolean)">hit</A></B>(java.awt.Rectangle&nbsp;rect,
    java.awt.Shape&nbsp;s,
    boolean&nbsp;onStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether or not the specified <code>Shape</code> intersects 
 the specified Rectangle, which is in device
 space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#println(java.lang.String)">println</A></B>(java.lang.String&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a line to the output. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#println(java.lang.String[])">println</A></B>(java.lang.String[]&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a sequence of lines to the output. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#printlnDef(java.lang.String)">printlnDef</A></B>(java.lang.String&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print a line to the defintion section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#rotate(double)">rotate</A></B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a rotation transform.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#rotate(double, double, double)">rotate</A></B>(double&nbsp;theta,
       double&nbsp;x,
       double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current <code>Graphics2D</code> 
 <code>Transform</code> with a translated rotation 
 transform.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#scale(double, double)">scale</A></B>(double&nbsp;sx,
      double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a scaling transformation.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setBackground(java.awt.Color)">setBackground</A></B>(java.awt.Color&nbsp;colour)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the background colour for the <code>Graphics2D</code> context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setClip(int, int, int, int)">setClip</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current clip to the rectangle specified by the given
 coordinates.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setClip(java.awt.Shape)">setClip</A></B>(java.awt.Shape&nbsp;clip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current clipping area to an arbitrary clip shape.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setColor(java.awt.Color)">setColor</A></B>(java.awt.Color&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store the current colour. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setComposite(java.awt.Composite)">setComposite</A></B>(java.awt.Composite&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current composite instance.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setFont(java.awt.Font)">setFont</A></B>(java.awt.Font&nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current font.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setPaint(java.awt.Paint)">setPaint</A></B>(java.awt.Paint&nbsp;paint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>Paint</code> attribute for the 
 <code>Graphics2D</code> context.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setPaintMode()">setPaintMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only plain paint mode is implemented for SVG.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)">setRenderingHint</A></B>(java.awt.RenderingHints.Key&nbsp;hintKey,
                 java.lang.Object&nbsp;hintValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the value of a single preference for the rendering algorithms.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setRenderingHints(java.util.Map)">setRenderingHints</A></B>(java.util.Map&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the values of all preferences for the rendering
 algorithms with the specified <code>hints</code>.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setStroke(java.awt.Stroke)">setStroke</A></B>(java.awt.Stroke&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A></B>(java.awt.geom.AffineTransform&nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>Transform</code> in the <code>Graphics2D</code>
 context.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setXORMode(java.awt.Color)">setXORMode</A></B>(java.awt.Color&nbsp;c1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting XOR mode.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#shear(double, double)">shear</A></B>(double&nbsp;shx,
      double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a shearing transform.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#transform(java.awt.geom.AffineTransform)">transform</A></B>(java.awt.geom.AffineTransform&nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Composes an <code>AffineTransform</code> object with the 
 <code>Transform</code> in this <code>Graphics2D</code> according 
 to the rule last-specified-first-applied.  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#translate(double, double)">translate</A></B>(double&nbsp;tx,
          double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current
 <code>Graphics2D</code> <code>Transform</code> 
 with a translation transform. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#translate(int, int)">translate</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates the current
 <code>Graphics2D</code> <code>Transform</code>.  </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Graphics2D"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.awt.Graphics2D</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>draw3DRect, fill3DRect</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Graphics"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.awt.Graphics</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>create, drawBytes, drawChars, drawPolygon, fillPolygon, finalize, getClipBounds, getClipRect, getFontMetrics, hitClip, toString</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="println(java.lang.String[])"><!-- --></A><H3>
println</H3>
<PRE>
public void <B>println</B>(java.lang.String[]&nbsp;arg)</PRE>
<DL>
<DD>Print a sequence of lines to the output. Users can use this method to put svg statements directly into the
 output stream. Note, however, that no semantic check is done on the string, so user have
 to know what they are doing!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - texts to be put appende to the output stream</DL>
</DD>
</DL>
<HR>

<A NAME="println(java.lang.String)"><!-- --></A><H3>
println</H3>
<PRE>
public void <B>println</B>(java.lang.String&nbsp;arg)</PRE>
<DL>
<DD>Print a line to the output. Users can use this method to put SVG statements directly into the
 output stream. Note, however, that no semantic check is done on the string, so user have
 to know what they are doing!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - text to be put appende to the output stream</DL>
</DD>
</DL>
<HR>

<A NAME="printlnDef(java.lang.String)"><!-- --></A><H3>
printlnDef</H3>
<PRE>
public void <B>printlnDef</B>(java.lang.String&nbsp;arg)</PRE>
<DL>
<DD>Print a line to the defintion section.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - text to be put append to the output stream</DL>
</DD>
</DL>
<HR>

<A NAME="create(java.io.PrintStream, java.awt.Component)"><!-- --></A><H3>
create</H3>
<PRE>
public static <A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html" title="class in ch.unibe.iam.util.graphics">SVGGraphics</A> <B>create</B>(java.io.PrintStream&nbsp;o,
                                 java.awt.Component&nbsp;origin)</PRE>
<DL>
<DD>Create a new <code>SVGGraphics</code> object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - output stream for the svg content<DD><CODE>origin</CODE> - the "parent" component. Its bounds will be used to determine the
 svg width and height parameters. If null, the values 400 and 400 will be used.
<DT><B>Returns:</B><DD>the new <code>SVGGraphics</code> object.</DL>
</DD>
</DL>
<HR>

<A NAME="close(boolean)"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>(boolean&nbsp;closeFile)</PRE>
<DL>
<DD>Close the object. This will flush the buffers for the SVG file properly. It is 
 imperative for the user to issue this call before closing the object, otherwise the
 SVG file will not be generated!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>closeFile</CODE> - if true, a 'close' command will also be issued on the <code>PrintStream</code>, too.</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()</PRE>
<DL>
<DD>Close the object. This will close the SVG file properly and flush the buffers. It is 
 imperative for the user to issue this call before closing the object, otherwise the
 SVG file will not be generated! The <code>PrintStream</code> object will also be closed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>This method is inherited from the superclass. On its own 
 the method issues simple <A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#close(boolean)"><CODE><code>close</code></CODE></A>. In this sense, using this method is an alternative
 to the <code>close</code> method.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#close(boolean)"><CODE>close(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="create()"><!-- --></A><H3>
create</H3>
<PRE>
public java.awt.Graphics <B>create</B>()</PRE>
<DL>
<DD>Creates a new <code>Graphics</code> object that is 
 a copy of this <code>Graphics</code> object. This method is mandated by the
 superclass but,
 for the case of SVG, it does not
 really make sense, because the internal buffers are not be copied. The call is
 here to make the java compiler happy...
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a new graphics context that is a copy of this graphics context.</DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(double&nbsp;tx,
                      double&nbsp;ty)</PRE>
<DL>
<DD>Concatenates the current
 <code>Graphics2D</code> <code>Transform</code> 
 with a translation transform. A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - the distance to translate along the x-axis<DD><CODE>ty</CODE> - the distance to translate along the y-axis</DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>Concatenates the current
 <code>Graphics2D</code> <code>Transform</code>.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate.<DD><CODE>y</CODE> - the <i>y</i> coordinate.</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a rotation transform.  A new group will be created in SVG.
 x axis toward the positive y axis.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - the angle of rotation in radians</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   double&nbsp;x,
                   double&nbsp;y)</PRE>
<DL>
<DD>Concatenates the current <code>Graphics2D</code> 
 <code>Transform</code> with a translated rotation 
 transform.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - the angle of rotation in radians</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;sx,
                  double&nbsp;sy)</PRE>
<DL>
<DD>Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a scaling transformation.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sx</CODE> - the amount by which X coordinates in subsequent
 rendering operations are multiplied relative to previous
 rendering operations.<DD><CODE>sy</CODE> - the amount by which Y coordinates in subsequent 
 rendering operations are multiplied relative to previous 
 rendering operations.</DL>
</DD>
</DL>
<HR>

<A NAME="shear(double, double)"><!-- --></A><H3>
shear</H3>
<PRE>
public void <B>shear</B>(double&nbsp;shx,
                  double&nbsp;shy)</PRE>
<DL>
<DD>Concatenates the current <code>Graphics2D</code>
 <code>Transform</code> with a shearing transform.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shx</CODE> - the multiplier by which coordinates are shifted in 
 the positive X axis direction as a function of their Y coordinate<DD><CODE>shy</CODE> - the multiplier by which coordinates are shifted in
 the positive Y axis direction as a function of their X coordinate</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.AffineTransform)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(java.awt.geom.AffineTransform&nbsp;Tx)</PRE>
<DL>
<DD>Composes an <code>AffineTransform</code> object with the 
 <code>Transform</code> in this <code>Graphics2D</code> according 
 to the rule last-specified-first-applied.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Tx</CODE> - the <code>AffineTransform</code> object to be composed with 
 the current <code>Transform</code><DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>, 
<CODE>AffineTransform</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A><H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(java.awt.geom.AffineTransform&nbsp;Tx)</PRE>
<DL>
<DD>Sets the <code>Transform</code> in the <code>Graphics2D</code>
 context.  A new group will be created in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Tx</CODE> - the <code>AffineTransform</code> object to be used in the
 rendering process</DL>
</DD>
</DL>
<HR>

<A NAME="getTransform()"><!-- --></A><H3>
getTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>getTransform</B>()</PRE>
<DL>
<DD>Returns a <em>copy</em> of the current <code>Transform</code> in the 
 <code>Graphics2D</code> context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current <code>AffineTransform</code> in the 
             <code>Graphics2D</code> context.</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A><H3>
getColor</H3>
<PRE>
public java.awt.Color <B>getColor</B>()</PRE>
<DL>
<DD>Gets this graphics context's current color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>this graphics context's current color.</DL>
</DD>
</DL>
<HR>

<A NAME="setColor(java.awt.Color)"><!-- --></A><H3>
setColor</H3>
<PRE>
public void <B>setColor</B>(java.awt.Color&nbsp;c)</PRE>
<DL>
<DD>Store the current colour. This will be the current 'paint' too, because <code>Color</code> also
 implements the <code>Paint</code> interface.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - new colour object</DL>
</DD>
</DL>
<HR>

<A NAME="setPaint(java.awt.Paint)"><!-- --></A><H3>
setPaint</H3>
<PRE>
public void <B>setPaint</B>(java.awt.Paint&nbsp;paint)</PRE>
<DL>
<DD>Sets the <code>Paint</code> attribute for the 
 <code>Graphics2D</code> context.
 <p><strong>The <code>TexturePaint</code> requires that the image would
 should have the "url" property!</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>paint</CODE> - new paint object</DL>
</DD>
</DL>
<HR>

<A NAME="getPaint()"><!-- --></A><H3>
getPaint</H3>
<PRE>
public java.awt.Paint <B>getPaint</B>()</PRE>
<DL>
<DD>Returns the current <code>Paint</code> of the 
 <code>Graphics2D</code> context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current <code>Graphics2D</code> <code>Paint</code>,
 which defines a color or pattern.</DL>
</DD>
</DL>
<HR>

<A NAME="setBackground(java.awt.Color)"><!-- --></A><H3>
setBackground</H3>
<PRE>
public void <B>setBackground</B>(java.awt.Color&nbsp;colour)</PRE>
<DL>
<DD>Sets the background colour for the <code>Graphics2D</code> context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>colour</CODE> - the background colour that is used in
 subsequent calls to <code>clearRect</code></DL>
</DD>
</DL>
<HR>

<A NAME="getBackground()"><!-- --></A><H3>
getBackground</H3>
<PRE>
public java.awt.Color <B>getBackground</B>()</PRE>
<DL>
<DD>Returns the background colour used for clearing a region.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current <code>Color</code>,
 which defines the background color.<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setBackground(java.awt.Color)"><CODE>setBackground(java.awt.Color)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setPaintMode()"><!-- --></A><H3>
setPaintMode</H3>
<PRE>
public void <B>setPaintMode</B>()</PRE>
<DL>
<DD>Only plain paint mode is implemented for SVG.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setXORMode(java.awt.Color)"><!-- --></A><H3>
setXORMode</H3>
<PRE>
public void <B>setXORMode</B>(java.awt.Color&nbsp;c1)</PRE>
<DL>
<DD>Setting XOR mode.
 <p><strong>XOR mode is not implemented!</strong>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setStroke(java.awt.Stroke)"><!-- --></A><H3>
setStroke</H3>
<PRE>
public void <B>setStroke</B>(java.awt.Stroke&nbsp;s)</PRE>
<DL>
<DD>Sets the <code>Stroke</code> for the <code>Graphics2D</code> context.
 A new group will be created in SVG.
 <p>The only implementing class of this interface in Java 1.2 is <code>BasicStroke</code>,
 and this assumption is used in the code (to retrieve linewidth, dash array, etc.). If users
 add their own <code>Stroke</code> implementations, or if new ones appear in later releases
 of Java, this has to be extended.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>Stroke</code> object to be used to stroke a 
 <code>Shape</code> during the rendering process</DL>
</DD>
</DL>
<HR>

<A NAME="getStroke()"><!-- --></A><H3>
getStroke</H3>
<PRE>
public java.awt.Stroke <B>getStroke</B>()</PRE>
<DL>
<DD>Returns the current <code>Stroke</code>.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setComposite(java.awt.Composite)"><!-- --></A><H3>
setComposite</H3>
<PRE>
public void <B>setComposite</B>(java.awt.Composite&nbsp;comp)</PRE>
<DL>
<DD>Sets the current composite instance.
 <p>The only implementing class of this interface in Java 1.2 is <code>AlphaComposite</code>,
 and this assumption is used in the code (to retrieve alpha values). If users
 add their own <code>Composite</code> implementations, or if new ones appear in later releases
 of Java, this has to be extended.
 <p>The only used attribute of the composite class is the alpha value (through the
 <code>getAlpha()</code>) which is used to set the opacity. I would not know, at this moment,
 how to translate the complicated composition rules of Java into SVG statements.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>comp</CODE> - the <code>Composite</code> object to be used for rendering.</DL>
</DD>
</DL>
<HR>

<A NAME="getComposite()"><!-- --></A><H3>
getComposite</H3>
<PRE>
public java.awt.Composite <B>getComposite</B>()</PRE>
<DL>
<DD>Returns the current <code>Composite</code> in the
 <code>Graphics2D</code> context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current <code>Graphics2D</code> <code>Composite</code>,
              which defines a compositing style.<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A><H3>
getFont</H3>
<PRE>
public java.awt.Font <B>getFont</B>()</PRE>
<DL>
<DD>Gets the current font.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current font.</DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A><H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(java.awt.Font&nbsp;font)</PRE>
<DL>
<DD>Sets the current font.
 <p>
 There are some small problems in implementing this method. Indeed, a java user can also set a "logical"
 font, ie, using a "logical" name for the font instead of the exact family. Of course, the set of
 available logical names in Java (Dialog, DialogInput, Monospaces, Serif, SansSerif, and Symbol) is 
 <em>not</em> identical with SVG (more exactly, CSS). It is not clear in Java what Dialog and
 DialogInput mean and there is no such symbolic font name in CSS either. On a Windows NT environment
 Dialog seems to be mapped onto sans serif, and DialogInput seems to be mapped to monospaced,
 so this is what is used.
 <p>
 If "real" font family name is used, it is used without any change for SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>font</CODE> - the new font</DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics(java.awt.Font)"><!-- --></A><H3>
getFontMetrics</H3>
<PRE>
public java.awt.FontMetrics <B>getFontMetrics</B>(java.awt.Font&nbsp;f)</PRE>
<DL>
<DD>Gets the font metrics for the specified font.
 <p>
 <strong>This is only partially implemented</strong>. There is no real way of inquiring about
 font data in SVG, so this method is only approximative. As a help for the user, if the
 "parent" component has been set, then the font metrics generated by that component is returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - the specified font
<DT><B>Returns:</B><DD>the font metrics for the specified font.</DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int)"><!-- --></A><H3>
drawString</H3>
<PRE>
public void <B>drawString</B>(java.lang.String&nbsp;s,
                       int&nbsp;x,
                       int&nbsp;y)</PRE>
<DL>
<DD>Renders the text of the specified <code>String</code>, using the 
 current <code>Font</code> and <code>Paint</code> attributes in the 
 <code>Graphics2D</code> context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the string to be dislplayed<DD><CODE>x</CODE> - x coordinate for the start of the string<DD><CODE>y</CODE> - y coordinate for the start of the string</DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, float, float)"><!-- --></A><H3>
drawString</H3>
<PRE>
public void <B>drawString</B>(java.lang.String&nbsp;s,
                       float&nbsp;x,
                       float&nbsp;y)</PRE>
<DL>
<DD>Renders the text specified by the specified <code>String</code>, 
 using the current <code>Font</code> and <code>Paint</code> attributes 
 in the <code>Graphics2D</code> context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - x coordinate for the start of the string<DD><CODE>y</CODE> - y coordinate for the start of the string</DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, int, int)"><!-- --></A><H3>
drawString</H3>
<PRE>
public void <B>drawString</B>(java.text.AttributedCharacterIterator&nbsp;iterator,
                       int&nbsp;x,
                       int&nbsp;y)</PRE>
<DL>
<DD>Renders the text of the specified iterator, using the
 <code>Graphics2D</code> context's current <code>Paint</code>. 
 <p>
 <strong>This method is not yet implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>iterator</CODE> - character iterator<DD><CODE>x</CODE> - x coordinate for the start of the string<DD><CODE>y</CODE> - y coordinate for the start of the string</DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, float, float)"><!-- --></A><H3>
drawString</H3>
<PRE>
public void <B>drawString</B>(java.text.AttributedCharacterIterator&nbsp;iterator,
                       float&nbsp;x,
                       float&nbsp;y)</PRE>
<DL>
<DD>Renders the text of the specified iterator, using the
 <code>Graphics2D</code> context's current <code>Paint</code>. 
 <p>
 <strong>This method is not yet implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>iterator</CODE> - character iterator<DD><CODE>x</CODE> - x coordinate for the start of the string<DD><CODE>y</CODE> - y coordinate for the start of the string</DL>
</DD>
</DL>
<HR>

<A NAME="drawGlyphVector(java.awt.font.GlyphVector, float, float)"><!-- --></A><H3>
drawGlyphVector</H3>
<PRE>
public void <B>drawGlyphVector</B>(java.awt.font.GlyphVector&nbsp;g,
                            float&nbsp;x,
                            float&nbsp;y)</PRE>
<DL>
<DD>Renders the text of the specified 
 GlyphVector using
 the <code>Graphics2D</code> context's rendering attributes.
 <p>
 <strong>This method is not yet implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - glyph vector<DD><CODE>x</CODE> - x coordinate for the start of the string<DD><CODE>y</CODE> - y coordinate for the start of the string</DL>
</DD>
</DL>
<HR>

<A NAME="getClipBounds()"><!-- --></A><H3>
getClipBounds</H3>
<PRE>
public java.awt.Rectangle <B>getClipBounds</B>()</PRE>
<DL>
<DD>Returns the bounding rectangle of the current clipping area.
 This method refers to the user clip, which is independent of the
 clipping associated with device bounds and window visibility.  
 If no clip has previously been set, or if the clip has been 
 cleared using <code>setClip(null)</code>, this method returns
 <code>null</code>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the bounding rectangle of the current clipping area,
              or <code>null</code> if no clip is set.</DL>
</DD>
</DL>
<HR>

<A NAME="clipRect(int, int, int, int)"><!-- --></A><H3>
clipRect</H3>
<PRE>
public void <B>clipRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Intersects the current clip with the specified rectangle.
 The resulting clipping area is the intersection of the current
 clipping area and the specified rectangle.  If there is no 
 current clipping area, either because the clip has never been 
 set, or the clip has been cleared using <code>setClip(null)</code>, 
 the specified rectangle becomes the new clip.
 <p>
 <strong>The intersection of clips with existing shapes is not implemented yet</strong>.
 In other words, this method is void, unless the current clip shape is not yet
 set, in which case it is equivalent to a <code>setClip</code> call.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - upper left hand corner x coordinate<DD><CODE>y</CODE> - upper left hand corner y coordinate<DD><CODE>width</CODE> - width of the rectangle<DD><CODE>height</CODE> - height of the rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="setClip(int, int, int, int)"><!-- --></A><H3>
setClip</H3>
<PRE>
public void <B>setClip</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD>Sets the current clip to the rectangle specified by the given
 coordinates.  This method sets the user clip, which is 
 independent of the clipping associated with device bounds
 and window visibility. 
 In SVG, a <code>clipPath</code> is generated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - upper left hand corner x coordinate<DD><CODE>y</CODE> - upper left hand corner y coordinate<DD><CODE>width</CODE> - width of the rectangle<DD><CODE>height</CODE> - height of the rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="getClip()"><!-- --></A><H3>
getClip</H3>
<PRE>
public java.awt.Shape <B>getClip</B>()</PRE>
<DL>
<DD>Gets the current clipping area.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClip(java.awt.Shape)"><!-- --></A><H3>
setClip</H3>
<PRE>
public void <B>setClip</B>(java.awt.Shape&nbsp;clip)</PRE>
<DL>
<DD>Sets the current clipping area to an arbitrary clip shape.
 <p>
 In SVG, a <code>clipPath</code> is generated.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clip</CODE> - the clip shape</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public void <B>copyArea</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height,
                     int&nbsp;dx,
                     int&nbsp;dy)</PRE>
<DL>
<DD>Copies an area of the component by a distance specified by 
 <code>dx</code> and <code>dy</code>.
 <p>
 <strong>This method is not yet implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the source rectangle.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the source rectangle.<DD><CODE>width</CODE> - the width of the source rectangle.<DD><CODE>height</CODE> - the height of the source rectangle.<DD><CODE>dx</CODE> - the horizontal distance to copy the pixels.<DD><CODE>dy</CODE> - the vertical distance to copy the pixels.</DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A><H3>
drawLine</H3>
<PRE>
public void <B>drawLine</B>(int&nbsp;x1,
                     int&nbsp;y1,
                     int&nbsp;x2,
                     int&nbsp;y2)</PRE>
<DL>
<DD>Draws a line.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the first point's <i>x</i> coordinate.<DD><CODE>y1</CODE> - the first point's <i>y</i> coordinate.<DD><CODE>x2</CODE> - the second point's <i>x</i> coordinate.<DD><CODE>y2</CODE> - the second point's <i>y</i> coordinate.</DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Shape)"><!-- --></A><H3>
draw</H3>
<PRE>
public void <B>draw</B>(java.awt.Shape&nbsp;s)</PRE>
<DL>
<DD>Strokes the outline of a <code>Shape</code> using the settings of the 
 current <code>Graphics2D</code> context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>Shape</code> to be rendered</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.awt.Shape)"><!-- --></A><H3>
fill</H3>
<PRE>
public void <B>fill</B>(java.awt.Shape&nbsp;s)</PRE>
<DL>
<DD>Fills the interior of a <code>Shape</code> using the settings of the   
 <code>Graphics2D</code> context. .
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>Shape</code> to be filled</DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A><H3>
drawRect</H3>
<PRE>
public void <B>drawRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Draws the specified rectangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate 
                         of the rectangle to be filled.<DD><CODE>y</CODE> - the <i>y</i> coordinate 
                         of the rectangle to be filled.<DD><CODE>width</CODE> - the width of the rectangle to be filled.<DD><CODE>height</CODE> - the height of the rectangle to be filled.</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A><H3>
fillRect</H3>
<PRE>
public void <B>fillRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Fills the specified rectangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate 
                         of the rectangle to be filled.<DD><CODE>y</CODE> - the <i>y</i> coordinate 
                         of the rectangle to be filled.<DD><CODE>width</CODE> - the width of the rectangle to be filled.<DD><CODE>height</CODE> - the height of the rectangle to be filled.</DL>
</DD>
</DL>
<HR>

<A NAME="clearRect(int, int, int, int)"><!-- --></A><H3>
clearRect</H3>
<PRE>
public void <B>clearRect</B>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height)</PRE>
<DL>
<DD>Clears the specified rectangle by filling it with the background
 color of the current drawing surface.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the rectangle to clear.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the rectangle to clear.<DD><CODE>width</CODE> - the width of the rectangle to clear.<DD><CODE>height</CODE> - the height of the rectangle to clear.</DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
drawRoundRect</H3>
<PRE>
public void <B>drawRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an outlined round-cornered rectangle using this graphics 
 context's current color. 
 <p>
 <strong>At present, the rounded rectangle is replaced by a plain rectangle.</strong> (SVG does
 not have the notion of rounded rectangle, and an appropriate path should be calculated instead,
 which has not been done.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the rectangle to be drawn.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the rectangle to be drawn.<DD><CODE>width</CODE> - the width of the rectangle to be drawn.<DD><CODE>height</CODE> - the height of the rectangle to be drawn.<DD><CODE>arcWidth</CODE> - the horizontal diameter of the arc 
                    at the four corners.<DD><CODE>arcHeight</CODE> - the vertical diameter of the arc 
                    at the four corners.</DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
fillRoundRect</H3>
<PRE>
public void <B>fillRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Fills the specified rounded corner rectangle with the current color.
 <p>
 <strong>At present, the rounded rectangle is replaced by a plain rectangle.</strong> (SVG does
 not have the notion of rounded rectangle, and an appropriate path should be calculated instead,
 which has not been done.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the rectangle to be filled.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the rectangle to be filled.<DD><CODE>width</CODE> - the width of the rectangle to be filled.<DD><CODE>height</CODE> - the height of the rectangle to be filled.<DD><CODE>arcWidth</CODE> - the horizontal diameter 
                     of the arc at the four corners.<DD><CODE>arcHeight</CODE> - the vertical diameter 
                     of the arc at the four corners.</DL>
</DD>
</DL>
<HR>

<A NAME="drawOval(int, int, int, int)"><!-- --></A><H3>
drawOval</H3>
<PRE>
public void <B>drawOval</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Draws the outline of an oval.
 <p> 
 An <code>ellipse</code> statement is generated in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the upper left 
                     corner of the oval to be drawn.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the upper left 
                     corner of the oval to be drawn.<DD><CODE>width</CODE> - the width of the oval to be drawn.<DD><CODE>height</CODE> - the height of the oval to be drawn.</DL>
</DD>
</DL>
<HR>

<A NAME="fillOval(int, int, int, int)"><!-- --></A><H3>
fillOval</H3>
<PRE>
public void <B>fillOval</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Fills an oval bounded by the specified rectangle with the
 current color.
 <p> 
 An <code>ellipse</code> statement is generated in SVG.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the upper left corner 
                     of the oval to be filled.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the upper left corner 
                     of the oval to be filled.<DD><CODE>width</CODE> - the width of the oval to be filled.<DD><CODE>height</CODE> - the height of the oval to be filled.</DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A><H3>
drawArc</H3>
<PRE>
public void <B>drawArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Draws the outline of a circular or elliptical arc 
 covering the specified rectangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the 
                    upper-left corner of the arc to be drawn.<DD><CODE>y</CODE> - the <i>y</i>  coordinate of the 
                    upper-left corner of the arc to be drawn.<DD><CODE>width</CODE> - the width of the arc to be drawn.<DD><CODE>height</CODE> - the height of the arc to be drawn.<DD><CODE>startAngle</CODE> - the beginning angle.<DD><CODE>arcAngle</CODE> - the angular extent of the arc, 
                    relative to the start angle.</DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A><H3>
fillArc</H3>
<PRE>
public void <B>fillArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Fills a circular or elliptical arc covering the specified rectangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the 
                    upper-left corner of the arc to be filled.<DD><CODE>y</CODE> - the <i>y</i>  coordinate of the 
                    upper-left corner of the arc to be filled.<DD><CODE>width</CODE> - the width of the arc to be filled.<DD><CODE>height</CODE> - the height of the arc to be filled.<DD><CODE>startAngle</CODE> - the beginning angle.<DD><CODE>arcAngle</CODE> - the angular extent of the arc, 
                    relative to the start angle.<DT><B>See Also:</B><DD><CODE>Graphics.drawArc(int, int, int, int, int, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="drawPolyline(int[], int[], int)"><!-- --></A><H3>
drawPolyline</H3>
<PRE>
public void <B>drawPolyline</B>(int[]&nbsp;xPoints,
                         int[]&nbsp;yPoints,
                         int&nbsp;nPoints)</PRE>
<DL>
<DD>Draws a sequence of connected lines defined by 
 arrays of <i>x</i> and <i>y</i> coordinates.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPoints</CODE> - an array of <i>x</i> points<DD><CODE>yPoints</CODE> - an array of <i>y</i> points<DD><CODE>nPoints</CODE> - the total number of points<DT><B>See Also:</B><DD><CODE>Graphics.drawPolygon(int[], int[], int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[], int[], int)"><!-- --></A><H3>
drawPolygon</H3>
<PRE>
public void <B>drawPolygon</B>(int[]&nbsp;xPoints,
                        int[]&nbsp;yPoints,
                        int&nbsp;nPoints)</PRE>
<DL>
<DD>Draws a closed polygon defined by 
 arrays of <i>x</i> and <i>y</i> coordinates. 
 Each pair of (<i>x</i>,&nbsp;<i>y</i>) coordinates defines a point.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPoints</CODE> - a an array of <code>x</code> coordinates.<DD><CODE>yPoints</CODE> - a an array of <code>y</code> coordinates.<DD><CODE>nPoints</CODE> - a the total number of points.</DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[], int[], int)"><!-- --></A><H3>
fillPolygon</H3>
<PRE>
public void <B>fillPolygon</B>(int[]&nbsp;xPoints,
                        int[]&nbsp;yPoints,
                        int&nbsp;nPoints)</PRE>
<DL>
<DD>Fills a closed polygon defined by 
 arrays of <i>x</i> and <i>y</i> coordinates.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPoints</CODE> - a an array of <code>x</code> coordinates.<DD><CODE>yPoints</CODE> - a an array of <code>y</code> coordinates.<DD><CODE>nPoints</CODE> - a the total number of points.<DT><B>See Also:</B><DD><CODE>Graphics.drawPolygon(int[], int[], int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;x,
                         int&nbsp;y,
                         java.awt.image.ImageObserver&nbsp;obs)</PRE>
<DL>
<DD>Draws as much of the specified image as is currently available.
 <p>
 <strong>The image has to have the property <code>"url"</code>.</strong> See comments
 on the class level for further details.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn.<DD><CODE>x</CODE> - the <i>x</i> coordinate.<DD><CODE>y</CODE> - the <i>y</i> coordinate.<DD><CODE>obs</CODE> - object to be notified as more of 
                          the image is converted.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;width,
                         int&nbsp;height,
                         java.awt.image.ImageObserver&nbsp;obs)</PRE>
<DL>
<DD>Draws as much of the specified image as has already been scaled
 to fit inside the specified rectangle.
 <p>
 <strong>The image has to have the property <code>"url"</code>.</strong> See comments
 on the class level for further details.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn.<DD><CODE>x</CODE> - the <i>x</i> coordinate.<DD><CODE>y</CODE> - the <i>y</i> coordinate.<DD><CODE>width</CODE> - the width of the rectangle.<DD><CODE>height</CODE> - the height of the rectangle.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;x,
                         int&nbsp;y,
                         java.awt.Color&nbsp;bgcolor,
                         java.awt.image.ImageObserver&nbsp;obs)</PRE>
<DL>
<DD>Draws as much of the specified image as is currently available.
 <p>
 <strong>The image has to have the property <code>"url"</code>.</strong> See comments
 on the class level for further details.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn.<DD><CODE>x</CODE> - the <i>x</i> coordinate.<DD><CODE>y</CODE> - the <i>y</i> coordinate.<DD><CODE>bgcolor</CODE> - the background color to paint under the
                         non-opaque portions of the image.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;width,
                         int&nbsp;height,
                         java.awt.Color&nbsp;bgcolor,
                         java.awt.image.ImageObserver&nbsp;obs)</PRE>
<DL>
<DD>Draws as much of the specified image as has already been scaled
 to fit inside the specified rectangle.
 <p>
 <strong>The image has to have the property <code>"url"</code>.</strong> See comments
 on the class level for further details.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn.<DD><CODE>x</CODE> - the <i>x</i> coordinate.<DD><CODE>y</CODE> - the <i>y</i> coordinate.<DD><CODE>width</CODE> - the width of the rectangle.<DD><CODE>height</CODE> - the height of the rectangle.<DD><CODE>bgcolor</CODE> - the background color to paint under the
                         non-opaque portions of the image.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;dx1,
                         int&nbsp;dy1,
                         int&nbsp;dx2,
                         int&nbsp;dy2,
                         int&nbsp;sx1,
                         int&nbsp;sy1,
                         int&nbsp;sx2,
                         int&nbsp;sy2,
                         java.awt.image.ImageObserver&nbsp;observer)</PRE>
<DL>
<DD>Draws as much of the specified area of the specified image as is
 currently available, scaling it on the fly to fit inside the
 specified area of the destination drawable surface. Transparent pixels 
 do not affect whatever pixels are already there.
 <p>
 <strong>Cutting part of the image is not yet implemented</strong>. (It would probably
 require to use some of the image filters defined in SVG, but this has not
 been checked.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn<DD><CODE>dx1</CODE> - the <i>x</i> coordinate of the first corner of the
                    destination rectangle.<DD><CODE>dy1</CODE> - the <i>y</i> coordinate of the first corner of the
                    destination rectangle.<DD><CODE>dx2</CODE> - the <i>x</i> coordinate of the second corner of the
                    destination rectangle.<DD><CODE>dy2</CODE> - the <i>y</i> coordinate of the second corner of the
                    destination rectangle.<DD><CODE>sx1</CODE> - the <i>x</i> coordinate of the first corner of the
                    source rectangle.<DD><CODE>sy1</CODE> - the <i>y</i> coordinate of the first corner of the
                    source rectangle.<DD><CODE>sx2</CODE> - the <i>x</i> coordinate of the second corner of the
                    source rectangle.<DD><CODE>sy2</CODE> - the <i>y</i> coordinate of the second corner of the
                    source rectangle.<DD><CODE>observer</CODE> - object to be notified as more of the image is
                    scaled and converted.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         int&nbsp;dx1,
                         int&nbsp;dy1,
                         int&nbsp;dx2,
                         int&nbsp;dy2,
                         int&nbsp;sx1,
                         int&nbsp;sy1,
                         int&nbsp;sx2,
                         int&nbsp;sy2,
                         java.awt.Color&nbsp;bgcolor,
                         java.awt.image.ImageObserver&nbsp;observer)</PRE>
<DL>
<DD>Draws as much of the specified area of the specified image as is
 currently available, scaling it on the fly to fit inside the
 specified area of the destination drawable surface. 
 <p>
 <strong>Cutting part of the image is not yet implemented</strong>. (It would probably
 require to use some of the image filters defined in SVG, but this has not
 been checked.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn<DD><CODE>dx1</CODE> - the <i>x</i> coordinate of the first corner of the
                    destination rectangle.<DD><CODE>dy1</CODE> - the <i>y</i> coordinate of the first corner of the
                    destination rectangle.<DD><CODE>dx2</CODE> - the <i>x</i> coordinate of the second corner of the
                    destination rectangle.<DD><CODE>dy2</CODE> - the <i>y</i> coordinate of the second corner of the
                    destination rectangle.<DD><CODE>sx1</CODE> - the <i>x</i> coordinate of the first corner of the
                    source rectangle.<DD><CODE>sy1</CODE> - the <i>y</i> coordinate of the first corner of the
                    source rectangle.<DD><CODE>sx2</CODE> - the <i>x</i> coordinate of the second corner of the
                    source rectangle.<DD><CODE>sy2</CODE> - the <i>y</i> coordinate of the second corner of the
                    source rectangle.<DD><CODE>bgcolor</CODE> - the background color to paint under the
                    non-opaque portions of the image.<DD><CODE>observer</CODE> - object to be notified as more of the image is
                    scaled and converted.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public boolean <B>drawImage</B>(java.awt.Image&nbsp;img,
                         java.awt.geom.AffineTransform&nbsp;xform,
                         java.awt.image.ImageObserver&nbsp;obs)</PRE>
<DL>
<DD>Renders an image, applying a transform from image space into user space
 before drawing.
 <p>
 The method is implemented by enclosing a usual image call into a
 group with the right transformation. 
 <p>
 <strong>The image has to have the property <code>"url"</code>.</strong> See comments
 on the class level for further details.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the <code>Image</code> to be rendered<DD><CODE>xform</CODE> - the transformation from image space into user space<DD><CODE>obs</CODE> - the ImageObserver
 to be notified as more of the <code>Image</code>
 is converted
<DT><B>Returns:</B><DD><code>true</code> if the image could be displayed, and <code>false</code> otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public void <B>drawImage</B>(java.awt.image.BufferedImage&nbsp;img,
                      java.awt.image.BufferedImageOp&nbsp;op,
                      int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>Renders a <code>BufferedImage</code>.
 <p>
 <strong>Handling of Buffered Images is not implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>op</CODE> - the filter to be applied to the image before rendering<DD><CODE>img</CODE> - the <code>BufferedImage</code> to be rendered<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><!-- --></A><H3>
drawRenderedImage</H3>
<PRE>
public void <B>drawRenderedImage</B>(java.awt.image.RenderedImage&nbsp;img,
                              java.awt.geom.AffineTransform&nbsp;xform)</PRE>
<DL>
<DD>Draws a rendered image
 <p><strong>Handling of rendered images is not implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the image to be rendered<DD><CODE>xform</CODE> - the transformation from image space into user space<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)"><!-- --></A><H3>
drawRenderableImage</H3>
<PRE>
public void <B>drawRenderableImage</B>(java.awt.image.renderable.RenderableImage&nbsp;img,
                                java.awt.geom.AffineTransform&nbsp;xform)</PRE>
<DL>
<DD>Draws a renderable image
 <p><strong>Handling of renderable images is not implemented.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the image to be rendered<DD><CODE>xform</CODE> - the transformation from image space into user space<DT><B>See Also:</B><DD><A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../ch/unibe/iam/util/graphics/SVGGraphics.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><CODE>drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hit(java.awt.Rectangle, java.awt.Shape, boolean)"><!-- --></A><H3>
hit</H3>
<PRE>
public boolean <B>hit</B>(java.awt.Rectangle&nbsp;rect,
                   java.awt.Shape&nbsp;s,
                   boolean&nbsp;onStroke)</PRE>
<DL>
<DD>Checks whether or not the specified <code>Shape</code> intersects 
 the specified Rectangle, which is in device
 space.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if there is a hit; <code>false</code> 
 otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)"><!-- --></A><H3>
setRenderingHint</H3>
<PRE>
public void <B>setRenderingHint</B>(java.awt.RenderingHints.Key&nbsp;hintKey,
                             java.lang.Object&nbsp;hintValue)</PRE>
<DL>
<DD>Sets the value of a single preference for the rendering algorithms.
 <p>
 <strong>This method has no effect in SVG.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hintKey</CODE> - the key of the hint to be set.<DD><CODE>hintValue</CODE> - the value indicating preferences for the specified
 hint category.<DT><B>See Also:</B><DD><CODE>RenderingHints</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHint(java.awt.RenderingHints.Key)"><!-- --></A><H3>
getRenderingHint</H3>
<PRE>
public java.lang.Object <B>getRenderingHint</B>(java.awt.RenderingHints.Key&nbsp;hintKey)</PRE>
<DL>
<DD>Returns the value of a single preference for the rendering algorithms.
 <p>
 <strong>The returned values are constants and, in a sense, meaningless</strong>.
 The rendering quality depends on the quality of the SVG browser, and not the 
 SVG file itself, so the assumption is that the browser is of the highest quality.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hintKey</CODE> - the key corresponding to the hint to get.
<DT><B>Returns:</B><DD>an object representing the value for the specified hint key.
 Some of the keys and their associated values are defined in the
 <code>RenderingHints</code> class.<DT><B>See Also:</B><DD><CODE>RenderingHints</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHints(java.util.Map)"><!-- --></A><H3>
setRenderingHints</H3>
<PRE>
public void <B>setRenderingHints</B>(java.util.Map&nbsp;hints)</PRE>
<DL>
<DD>Replaces the values of all preferences for the rendering
 algorithms with the specified <code>hints</code>.
 <p>
 <strong>The method is void and, in a sense, meaningless</strong>.
 The rendering quality depends on the quality of the SVG browser, and not the 
 SVG file itself, so the assumption is that the browser is of the highest quality.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hints</CODE> - the rendering hints to be set<DT><B>See Also:</B><DD><CODE>RenderingHints</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="addRenderingHints(java.util.Map)"><!-- --></A><H3>
addRenderingHints</H3>
<PRE>
public void <B>addRenderingHints</B>(java.util.Map&nbsp;hints)</PRE>
<DL>
<DD>Sets the values of an arbitrary number of preferences for the
 rendering algorithms.
 <p>
 <strong>The method is void and, in a sense, meaningless</strong>.
 The rendering quality depends on the quality of the SVG browser, and not the 
 SVG file itself, so the assumption is that the browser is of the highest quality.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hints</CODE> - the rendering hints to be set<DT><B>See Also:</B><DD><CODE>RenderingHints</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHints()"><!-- --></A><H3>
getRenderingHints</H3>
<PRE>
public java.awt.RenderingHints <B>getRenderingHints</B>()</PRE>
<DL>
<DD>Gets the preferences for the rendering algorithms.
 <p>
 <strong>The returned values are constants and, in a sense, meaningless</strong>.
 The rendering quality depends on the quality of the SVG browser, and not the 
 SVG file itself, so the assumption is that the browser is of the highest quality.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a reference to an instance of <code>RenderingHints</code>
 that contains the current preferences.<DT><B>See Also:</B><DD><CODE>RenderingHints</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="clip(java.awt.Shape)"><!-- --></A><H3>
clip</H3>
<PRE>
public void <B>clip</B>(java.awt.Shape&nbsp;s)</PRE>
<DL>
<DD>Intersects the current <code>Clip</code> with the interior of the
 specified <code>Shape</code> and sets the <code>Clip</code> to the
 resulting intersection. 
 <p>
 <strong>This method has not been implemented yet.</strong>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the <code>Shape</code> to be intersected with the current
          <code>Clip</code>.  If <code>s</code> is <code>null</code>,
          this method clears the current <code>Clip</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="getFontRenderContext()"><!-- --></A><H3>
getFontRenderContext</H3>
<PRE>
public java.awt.font.FontRenderContext <B>getFontRenderContext</B>()</PRE>
<DL>
<DD>Get the rendering context of the <code>Font</code> within this 
 <code>Graphics2D</code> context.
 <p>
 There is no real counterpart in SVG for this. As a help to the user, if the parent component
 has been set <em>and</em> there is a current font, the rendering context for that
 environment is returned. This might help in having an idea on how big the chain of
 character will be, for example.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a reference to an instance of FontRenderContext.</DL>
</DD>
</DL>
<HR>

<A NAME="getDeviceConfiguration()"><!-- --></A><H3>
getDeviceConfiguration</H3>
<PRE>
public java.awt.GraphicsConfiguration <B>getDeviceConfiguration</B>()</PRE>
<DL>
<DD>Returns the device configuration associated with this 
 <code>Graphics2D</code>.
 <p>
 <strong>The implementation is fake.</strong> Just to give an indication to the
 user, it returns the graphics configuration of the "parent" (i.e., "real") component,
 although this might be meaningless for the display of the SVG file.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the graphics configuration of the "parent" component, if set, and null
 otherwise.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SVGGraphics.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../ch/unibe/iam/util/graphics/RegularPolygon.html" title="class in ch.unibe.iam.util.graphics"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SVGGraphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
